package constraineddelaunay

import (
	"encoding/hex"
	"flag"
	"log"
	"reflect"
	"strconv"
	"testing"

	"github.com/go-spatial/geom"
	"github.com/go-spatial/geom/encoding/wkb"
	"github.com/go-spatial/geom/encoding/wkt"
	"github.com/go-spatial/geom/planar/triangulate"
	"github.com/go-spatial/geom/planar/triangulate/quadedge"
)

var runAll bool

func init() {
	flag.BoolVar(&runAll, "run-all", false, "to run tests marked to be skipped")
}

func TestFindIntersectingTriangle(t *testing.T) {
	type tcase struct {
		// provided for readability
		inputWKT string
		// this can be removed if/when geom has a WKT decoder.
		// A simple website for performing conversions:
		// https://rodic.fr/blog/online-conversion-between-geometric-formats/
		inputWKB         string
		searchFrom       geom.Line
		expectedTriangle string
		err              error
	}

	fn := func(tc tcase) func(*testing.T) {
		return func(t *testing.T) {
			bytes, err := hex.DecodeString(tc.inputWKB)
			if err != nil {
				t.Fatalf("error decoding hex string: %v", err)
				return
			}
			g, err := wkb.DecodeBytes(bytes)
			if err != nil {
				t.Fatalf("error decoding WKB: %v", err)
				return
			}

			uut := new(Triangulator)
			uut.tolerance = 1e-6
			// perform self consistency validation while building the
			// triangulation.
			uut.validate = true
			uut.insertSites(g)

			// find the triangle
			tri, err := uut.findIntersectingTriangle(triangulate.NewSegment(tc.searchFrom))

			if reflect.TypeOf(err) != reflect.TypeOf(tc.err) {
				t.Fatalf("error, expected %v got %v", reflect.TypeOf(tc.err), reflect.TypeOf(err))
				return
			}

			if tc.err == nil {
				qeStr := tri.String()
				if qeStr != tc.expectedTriangle {
					t.Fatalf("error, expected %v got %v", tc.expectedTriangle, qeStr)
				}
			}
		}
	}
	testcases := []tcase{
		{
			inputWKT:         `MULTIPOINT (10 10, 10 20, 20 20, 20 10, 20 0, 10 0, 0 0, 0 10, 0 20)`,
			inputWKB:         `010400000009000000010100000000000000000024400000000000002440010100000000000000000024400000000000003440010100000000000000000034400000000000003440010100000000000000000034400000000000002440010100000000000000000034400000000000000000010100000000000000000024400000000000000000010100000000000000000000000000000000000000010100000000000000000000000000000000002440010100000000000000000000000000000000003440`,
			searchFrom:       geom.Line{{0, 0}, {10, 10}},
			expectedTriangle: `[[0 0],[0 10],[10 0]]`,
		},
		{
			inputWKT:         `MULTIPOINT (10 10, 10 20, 20 20, 20 10, 20 0, 10 0, 0 0, 0 10, 0 20)`,
			inputWKB:         `010400000009000000010100000000000000000024400000000000002440010100000000000000000024400000000000003440010100000000000000000034400000000000003440010100000000000000000034400000000000002440010100000000000000000034400000000000000000010100000000000000000024400000000000000000010100000000000000000000000000000000000000010100000000000000000000000000000000002440010100000000000000000000000000000000003440`,
			searchFrom:       geom.Line{{10, 0}, {0, 20}},
			expectedTriangle: `[[10 0],[0 10],[10 10]]`,
		},
		{
			inputWKT:         `MULTIPOINT (10 10, 10 20, 20 20, 20 10, 20 0, 10 0, 0 0, 0 10, 0 20)`,
			inputWKB:         `010400000009000000010100000000000000000024400000000000002440010100000000000000000024400000000000003440010100000000000000000034400000000000003440010100000000000000000034400000000000002440010100000000000000000034400000000000000000010100000000000000000024400000000000000000010100000000000000000000000000000000000000010100000000000000000000000000000000002440010100000000000000000000000000000000003440`,
			searchFrom:       geom.Line{{10, 10}, {0, 0}},
			expectedTriangle: `[[10 10],[10 0],[0 10]]`,
		},
		{
			inputWKT:         `MULTIPOINT (10 10, 10 20, 20 20, 20 10, 20 0, 10 0, 0 0, 0 10, 0 20)`,
			inputWKB:         `010400000009000000010100000000000000000024400000000000002440010100000000000000000024400000000000003440010100000000000000000034400000000000003440010100000000000000000034400000000000002440010100000000000000000034400000000000000000010100000000000000000024400000000000000000010100000000000000000000000000000000000000010100000000000000000000000000000000002440010100000000000000000000000000000000003440`,
			searchFrom:       geom.Line{{10, 10}, {10, 20}},
			expectedTriangle: `[[10 10],[10 20],[20 10]]`,
		},
		{
			inputWKT:         `MULTIPOINT (10 10, 10 20, 20 20, 20 10, 20 0, 10 0, 0 0, 0 10, 0 20)`,
			inputWKB:         `010400000009000000010100000000000000000024400000000000002440010100000000000000000024400000000000003440010100000000000000000034400000000000003440010100000000000000000034400000000000002440010100000000000000000034400000000000000000010100000000000000000024400000000000000000010100000000000000000000000000000000000000010100000000000000000000000000000000002440010100000000000000000000000000000000003440`,
			searchFrom:       geom.Line{{1000, 1000}, {10000, 20000}},
			expectedTriangle: ``,
			err:              quadedge.ErrLocateFailure{},
		},
	}

	for i, tc := range testcases {
		t.Run(strconv.FormatInt(int64(i), 10), fn(tc))
	}
}

func TestDeleteEdge(t *testing.T) {
	type tcase struct {
		// provided for readability
		inputWKT string
		// this can be removed if/when geom has a WKT decoder.
		// A simple website for performing conversions:
		// https://rodic.fr/blog/online-conversion-between-geometric-formats/
		inputWKB string
		deleteMe geom.Line
	}

	fn := func(tc tcase) func(*testing.T) {
		return func(t *testing.T) {
			bytes, err := hex.DecodeString(tc.inputWKB)
			if err != nil {
				t.Fatalf("error decoding hex string, expected nil got %v", err)
				return
			}
			g, err := wkb.DecodeBytes(bytes)
			if err != nil {
				t.Fatalf("error decoding WKB, expected nil got %v", err)
				return
			}

			uut := new(Triangulator)
			uut.tolerance = 1e-6
			// perform self consistency validation while building the
			// triangulation.
			uut.validate = true
			uut.InsertGeometry(g)
			e, err := uut.LocateSegment(quadedge.Vertex(tc.deleteMe[0]), quadedge.Vertex(tc.deleteMe[1]))
			if err != nil {
				t.Fatalf("error locating segment, expected nil got %v", err)
				return
			}

			err = uut.Validate()
			if err != nil {
				t.Errorf("error validating triangulation, expected nil got %v", err)
				return
			}

			if err = uut.deleteEdge(e); err != nil {
				t.Errorf("error deleting edge, expected nil got %v", err)
			}
			// we know validateTriangles will fail, so just validate the indexes.
			err = uut.validateVertexIndex()
			if err != nil {
				t.Errorf("error validating triangulation after delete, expected nil got %v", err)
				return
			}

			// this edge shouldn't exist anymore.
			_, err = uut.LocateSegment(quadedge.Vertex(tc.deleteMe[0]), quadedge.Vertex(tc.deleteMe[1]))
			if err == nil {
				t.Fatalf("error locating segment, expected %v got nil", quadedge.ErrLocateFailure{})
				return
			}

		}
	}
	testcases := []tcase{
		{
			inputWKT: `MULTIPOINT (10 10, 10 20, 20 20, 20 10, 20 0, 10 0, 0 0, 0 10, 0 20)`,
			inputWKB: `010400000009000000010100000000000000000024400000000000002440010100000000000000000024400000000000003440010100000000000000000034400000000000003440010100000000000000000034400000000000002440010100000000000000000034400000000000000000010100000000000000000024400000000000000000010100000000000000000000000000000000000000010100000000000000000000000000000000002440010100000000000000000000000000000000003440`,
			deleteMe: geom.Line{{0, 10}, {10, 0}},
		},
		{
			inputWKT: `MULTIPOINT (10 10, 10 20, 20 20, 20 10, 20 0, 10 0, 0 0, 0 10, 0 20)`,
			inputWKB: `010400000009000000010100000000000000000024400000000000002440010100000000000000000024400000000000003440010100000000000000000034400000000000003440010100000000000000000034400000000000002440010100000000000000000034400000000000000000010100000000000000000024400000000000000000010100000000000000000000000000000000000000010100000000000000000000000000000000002440010100000000000000000000000000000000003440`,
			deleteMe: geom.Line{{0, 10}, {10, 0}},
		},
	}

	for i, tc := range testcases {
		t.Run(strconv.FormatInt(int64(i), 10), fn(tc))
	}
}

func TestIntersection(t *testing.T) {
	type tcase struct {
		l1            triangulate.Segment
		l2            triangulate.Segment
		intersection  quadedge.Vertex
		expectedError error
	}

	fn := func(tc tcase) func(*testing.T) {
		return func(t *testing.T) {
			uut := new(Triangulator)
			uut.tolerance = 1e-2
			v, err := uut.intersection(tc.l1, tc.l2)
			if err != tc.expectedError {
				t.Errorf("error intersecting line segments, expected %v got %v", tc.expectedError, err)
				return
			}

			if v.Equals(tc.intersection) == false {
				t.Errorf("error validating intersection, expected %v got %v", tc.intersection, v)
			}
		}
	}
	testcases := []tcase{
		{
			l1:            triangulate.NewSegment(geom.Line{{0, 1}, {2, 3}}),
			l2:            triangulate.NewSegment(geom.Line{{1, 1}, {0, 2}}),
			intersection:  quadedge.Vertex{0.5, 1.5},
			expectedError: nil,
		},
		{
			l1:            triangulate.NewSegment(geom.Line{{0, 1}, {2, 4}}),
			l2:            triangulate.NewSegment(geom.Line{{1, 1}, {0, 2}}),
			intersection:  quadedge.Vertex{0.4, 1.6},
			expectedError: nil,
		},
		{
			l1:            triangulate.NewSegment(geom.Line{{0, 1}, {2, 3}}),
			l2:            triangulate.NewSegment(geom.Line{{1, 1}, {2, 2}}),
			intersection:  quadedge.Vertex{0, 0},
			expectedError: ErrLinesDoNotIntersect,
		},
		{
			l1:            triangulate.NewSegment(geom.Line{{3, 5}, {3, 6}}),
			l2:            triangulate.NewSegment(geom.Line{{1, 4.995}, {4, 4.995}}),
			intersection:  quadedge.Vertex{3, 5},
			expectedError: nil,
		},
	}

	for i, tc := range testcases {
		t.Run(strconv.FormatInt(int64(i), 10), fn(tc))
	}
}

/*
TestTriangulation test cases test for small constrained triangulations and
edge cases
*/
func TestTriangulation(t *testing.T) {
	type tcase struct {
		// provided for readability
		inputWKT string
		// this can be removed if/when geom has a WKT decoder.
		// A simple website for performing conversions:
		// https://rodic.fr/blog/online-conversion-between-geometric-formats/
		inputWKB      string
		expectedEdges string
		expectedTris  string
		skip          string
	}

	// to change the flags on the default logger
	log.SetFlags(log.LstdFlags | log.Lshortfile)

	fn := func(tc tcase) func(*testing.T) {
		return func(t *testing.T) {
			if tc.skip != "" && !runAll {
				t.Skipf(tc.skip)
				return
			}
			bytes, err := hex.DecodeString(tc.inputWKB)
			if err != nil {
				t.Fatalf("error decoding hex string: %v", err)
				return
			}
			g, err := wkb.DecodeBytes(bytes)
			if err != nil {
				t.Fatalf("error decoding WKB: %v", err)
				return
			}

			uut := new(Triangulator)
			uut.tolerance = 1e-6
			uut.validate = true
			err = uut.InsertGeometry(g)
			if err != nil {
				t.Fatalf("error inserting segments, expected nil got %v", err)
			}

			edges := uut.GetEdges()
			edgesWKT, err := wkt.EncodeString(edges)
			if err != nil {
				t.Errorf("error, expected nil got %v", err)
				return
			}
			if edgesWKT != tc.expectedEdges {
				t.Errorf("error, expected %v got %v", tc.expectedEdges, edgesWKT)
				return
			}

			tris, err := uut.GetTriangles()
			if err != nil {
				t.Errorf("error, expected nil got %v", err)
				return
			}
			trisWKT, err := wkt.EncodeString(tris)
			if err != nil {
				t.Errorf("error, expected nil got %v", err)
				return
			}
			if trisWKT != tc.expectedTris {
				t.Errorf("error, expected %v got %v", tc.expectedTris, trisWKT)
				return
			}
		}
	}
	testcases := []tcase{
		{
			// should create a triangulation w/ a vertical line (2 5, 2 -5).
			// The unconstrained version has a horizontal line
			inputWKT:      `LINESTRING(0 0, 2 5, 2 -5, 5 0)`,
			inputWKB:      `0102000000040000000000000000000000000000000000000000000000000000400000000000001440000000000000004000000000000014c000000000000014400000000000000000`,
			expectedEdges: `MULTILINESTRING ((2 5,5 0),(0 0,2 5),(0 0,2 -5),(2 -5,5 0),(2 -5,2 5))`,
			expectedTris:  `MULTIPOLYGON (((0 0,2 -5,2 5,0 0)),((2 5,2 -5,5 0,2 5)))`,
		},
		{
			// a horizontal rectangle w/ one diagonal line. The diagonal line
			// should be maintained and the top/bottom re-triangulated.
			inputWKT:      `MULTILINESTRING((0 0,0 1,1 1.1,2 1,2 0,1 0.1,0 0),(0 1,2 0))`,
			inputWKB:      `010500000002000000010200000007000000000000000000000000000000000000000000000000000000000000000000f03f000000000000f03f9a9999999999f13f0000000000000040000000000000f03f00000000000000400000000000000000000000000000f03f9a9999999999b93f000000000000000000000000000000000102000000020000000000000000000000000000000000f03f00000000000000400000000000000000`,
			expectedEdges: `MULTILINESTRING ((1 1.1,2 1),(0 1,1 1.1),(0 0,0 1),(0 0,2 0),(2 0,2 1),(1 1.1,2 0),(0 1,2 0),(1 0.1,2 0),(0 1,1 0.1),(0 0,1 0.1))`,
			expectedTris:  `MULTIPOLYGON (((0 1,0 0,1 0.1,0 1)),((0 1,1 0.1,2 0,0 1)),((0 1,2 0,1 1.1,0 1)),((1 1.1,2 0,2 1,1 1.1)),((0 0,2 0,1 0.1,0 0)))`,
		},
		{
			// an egg shape with one horizontal line. The horizontal line
			// should be maintained and the top/bottom re-triangulated.
			inputWKT:      `MULTILINESTRING((0 0,-0.1 0.5,0 1,0.5 1.2,1 1.3,1.5 1.2,2 1,2.1 0.5,2 0,1.5 -0.2,1 -0.3,0.5 -0.2,0 0),(-0.1 0.5,2.1 0.5))`,
			inputWKB:      `01050000000200000001020000000d000000000000000000000000000000000000009a9999999999b9bf000000000000e03f0000000000000000000000000000f03f000000000000e03f333333333333f33f000000000000f03fcdccccccccccf43f000000000000f83f333333333333f33f0000000000000040000000000000f03fcdcccccccccc0040000000000000e03f00000000000000400000000000000000000000000000f83f9a9999999999c9bf000000000000f03f333333333333d3bf000000000000e03f9a9999999999c9bf000000000000000000000000000000000102000000020000009a9999999999b9bf000000000000e03fcdcccccccccc0040000000000000e03f`,
			expectedEdges: `MULTILINESTRING ((1.5 1.2,2 1),(1 1.3,1.5 1.2),(0.5 1.2,1 1.3),(0 1,0.5 1.2),(-0.1 0.5,0 1),(-0.1 0.5,0 0),(0 0,0.5 -0.2),(0.5 -0.2,1 -0.3),(1 -0.3,1.5 -0.2),(1.5 -0.2,2 0),(2 0,2.1 0.5),(2 1,2.1 0.5),(1.5 1.2,2.1 0.5),(1 1.3,2.1 0.5),(-0.1 0.5,2.1 0.5),(-0.1 0.5,1 1.3),(-0.1 0.5,0.5 1.2),(1 -0.3,2.1 0.5),(-0.1 0.5,1 -0.3),(1.5 -0.2,2.1 0.5),(-0.1 0.5,0.5 -0.2))`,
			expectedTris:  `MULTIPOLYGON (((0 1,-0.1 0.5,0.5 1.2,0 1)),((0.5 1.2,-0.1 0.5,1 1.3,0.5 1.2)),((1 1.3,-0.1 0.5,2.1 0.5,1 1.3)),((1 1.3,2.1 0.5,1.5 1.2,1 1.3)),((1.5 1.2,2.1 0.5,2 1,1.5 1.2)),((1 -0.3,1.5 -0.2,2.1 0.5,1 -0.3)),((1 -0.3,2.1 0.5,-0.1 0.5,1 -0.3)),((1 -0.3,-0.1 0.5,0.5 -0.2,1 -0.3)),((0.5 -0.2,-0.1 0.5,0 0,0.5 -0.2)),((2.1 0.5,1.5 -0.2,2 0,2.1 0.5)))`,
		},
		{
			// a triangle with a line intersecting the top vertex. Where the
			// line intersects the vertex, the line should be broken into two
			// pieces and triangulated properly.
			inputWKT:      `MULTILINESTRING((0 0,-0.1 0.5,0 1,0.5 1.2,1 1.3,1.5 1.2,2 1,2.1 0.5,2 0,1.5 -0.2,1 -0.3,0.5 -0.2,0 0),(-0.1 0.5,2.1 0.5))`,
			inputWKB:      `01050000000200000001020000000400000000000000000000000000000000000000000000000000f03f000000000000f03f00000000000000400000000000000000000000000000000000000000000000000102000000020000000000000000000000000000000000f03f0000000000000040000000000000f03f`,
			expectedEdges: `MULTILINESTRING ((1 1,2 1),(0 1,1 1),(0 0,0 1),(0 0,2 0),(2 0,2 1),(1 1,2 0),(0 0,1 1))`,
			expectedTris:  `MULTIPOLYGON (((0 1,0 0,1 1,0 1)),((1 1,0 0,2 0,1 1)),((1 1,2 0,2 1,1 1)))`,
		},
		{
			// a figure eight with a duplicate constrained line.
			inputWKT:      `MULTIPOLYGON (((0 0,0 1,1 1,1 0,0 0,0 -1,1 -1,1 0,0 0)))`,
			inputWKB:      `01060000000100000001030000000100000009000000000000000000000000000000000000000000000000000000000000000000f03f000000000000f03f000000000000f03f000000000000f03f0000000000000000000000000000000000000000000000000000000000000000000000000000f0bf000000000000f03f000000000000f0bf000000000000f03f000000000000000000000000000000000000000000000000`,
			expectedEdges: `MULTILINESTRING ((0 1,1 1),(0 0,0 1),(0 -1,0 0),(0 -1,1 -1),(1 -1,1 0),(1 0,1 1),(0 1,1 0),(0 0,1 0),(0 0,1 -1))`,
			expectedTris:  `MULTIPOLYGON (((0 1,0 0,1 0,0 1)),((0 1,1 0,1 1,0 1)),((0 -1,1 -1,0 0,0 -1)),((0 0,1 -1,1 0,0 0)))`,
		},
		{
			// A constraint line that overlaps with another edge
			inputWKT:      `MULTIPOLYGON (((0 0,1 1,2 1,3 0,3 1,0 1,0 0)))`,
			inputWKB:      `0106000000010000000103000000010000000700000000000000000000000000000000000000000000000000f03f000000000000f03f0000000000000040000000000000f03f000000000000084000000000000000000000000000000840000000000000f03f0000000000000000000000000000f03f00000000000000000000000000000000`,
			expectedEdges: `MULTILINESTRING ((2 1,3 1),(1 1,2 1),(0 1,1 1),(0 0,0 1),(0 0,3 0),(3 0,3 1),(2 1,3 0),(0 0,2 1),(0 0,1 1))`,
			expectedTris:  `MULTIPOLYGON (((0 1,0 0,1 1,0 1)),((1 1,0 0,2 1,1 1)),((2 1,0 0,3 0,2 1)),((2 1,3 0,3 1,2 1)))`,
		},
		{
			// bow-tie
			inputWKT:      `MULTIPOLYGON (((0 0,1 1,1 0,0 1,0 0)))`,
			inputWKB:      `0106000000010000000103000000010000000500000000000000000000000000000000000000000000000000f03f000000000000f03f000000000000f03f00000000000000000000000000000000000000000000f03f00000000000000000000000000000000`,
			expectedEdges: `MULTILINESTRING ((0 1,1 1),(0 0,0 1),(0 0,1 0),(1 0,1 1),(0.5 0.5,1 0),(0.5 0.5,1 1),(0 1,0.5 0.5),(0 0,0.5 0.5))`,
			expectedTris:  `MULTIPOLYGON (((0 1,0 0,0.5 0.5,0 1)),((0 1,0.5 0.5,1 1,0 1)),((1 1,0.5 0.5,1 0,1 1)),((0 0,1 0,0.5 0.5,0 0)))`,
		},
		{
			// Bow-tie with four sided concave polygon on left and triangle on
			// right. Should break into two polygons
			inputWKT:      `POLYGON ((0 0, 0.2 0.3, 0 1, 2 0, 2 1, 0 0))`,
			inputWKB:      `01030000000100000006000000000000000000000000000000000000009a9999999999c93f333333333333d33f0000000000000000000000000000f03f000000000000004000000000000000000000000000000040000000000000f03f00000000000000000000000000000000`,
			expectedEdges: `MULTILINESTRING ((0 1,2 1),(0 0,0 1),(0 0,2 0),(2 0,2 1),(1 0.5,2 0),(1 0.5,2 1),(0 1,1 0.5),(0.2 0.3,1 0.5),(0 1,0.2 0.3),(0 0,0.2 0.3),(0 0,1 0.5))`,
			expectedTris:  `MULTIPOLYGON (((0 1,0 0,0.2 0.3,0 1)),((0 1,0.2 0.3,1 0.5,0 1)),((0 1,1 0.5,2 1,0 1)),((2 1,1 0.5,2 0,2 1)),((0 0,2 0,1 0.5,0 0)),((0 0,1 0.5,0.2 0.3,0 0)))`,
		},
		{
			// Complex multipolygon w/ erroneous overlap
			inputWKT:      `MULTIPOLYGON(((40 40,20 45,28 10,40 40)),((20 35,10 30,10 10,30 5,45 20,20 35)))`,
			inputWKB:      `0106000000020000000103000000010000000400000000000000000044400000000000004440000000000000344000000000008046400000000000003c40000000000000244000000000000044400000000000004440010300000001000000060000000000000000003440000000000080414000000000000024400000000000003e40000000000000244000000000000024400000000000003e4000000000000014400000000000804640000000000000344000000000000034400000000000804140`,
			expectedEdges: `MULTILINESTRING ((20 45,40 40),(10 30,20 45),(10 10,10 30),(10 10,30 5),(30 5,45 20),(40 40,45 20),(34.516 26.29,45 20),(34.516 26.29,40 40),(22.649 33.411,34.516 26.29),(22.649 33.411,40 40),(20 45,22.649 33.411),(20 35,22.649 33.411),(20 35,20 45),(10 30,20 35),(20 35,28 10),(10 30,28 10),(10 10,28 10),(28 10,30 5),(28 10,45 20),(28 10,34.516 26.29),(22.649 33.411,28 10))`,
			expectedTris:  `MULTIPOLYGON (((10 30,10 10,28 10,10 30)),((10 30,28 10,20 35,10 30)),((10 30,20 35,20 45,10 30)),((20 45,20 35,22.649 33.411,20 45)),((20 45,22.649 33.411,40 40,20 45)),((40 40,22.649 33.411,34.516 26.29,40 40)),((40 40,34.516 26.29,45 20,40 40)),((30 5,45 20,28 10,30 5)),((30 5,28 10,10 10,30 5)),((28 10,45 20,34.516 26.29,28 10)),((28 10,34.516 26.29,22.649 33.411,28 10)),((28 10,22.649 33.411,20 35,28 10)))`,
		},
		{
			// Overlapping multipolygon w/ hole. Should produce a single
			// polygon with a smaller hole
			inputWKT:      `MULTIPOLYGON(((40 40,20 45,28 10,40 40)),((15 35,10 30,10 10,30 5,45 20,15 35),(30 20,20 15,20 25,30 20)))`,
			inputWKB:      `0106000000020000000103000000010000000400000000000000000044400000000000004440000000000000344000000000008046400000000000003c40000000000000244000000000000044400000000000004440010300000002000000060000000000000000002e40000000000080414000000000000024400000000000003e40000000000000244000000000000024400000000000003e400000000000001440000000000080464000000000000034400000000000002e400000000000804140040000000000000000003e40000000000000344000000000000034400000000000002e40000000000000344000000000000039400000000000003e400000000000003440`,
			expectedEdges: `MULTILINESTRING ((20 45,40 40),(10 30,20 45),(10 10,10 30),(10 10,30 5),(30 5,45 20),(40 40,45 20),(34.167 25.417,45 20),(34.167 25.417,40 40),(23.226 30.887,34.167 25.417),(23.226 30.887,40 40),(20 45,23.226 30.887),(15 35,23.226 30.887),(15 35,20 45),(10 30,15 35),(15 35,20 25),(10 30,20 25),(20 15,20 25),(10 30,20 15),(10 10,20 15),(20 15,28 10),(10 10,28 10),(28 10,30 5),(28 10,45 20),(28 10,34.167 25.417),(28 10,30 20),(30 20,34.167 25.417),(25.161 22.419,30 20),(25.161 22.419,34.167 25.417),(23.226 30.887,25.161 22.419),(20 25,25.161 22.419),(20 25,23.226 30.887),(20 15,25.161 22.419),(25.161 22.419,26.154 18.077),(20 15,26.154 18.077),(26.154 18.077,28 10),(26.154 18.077,30 20))`,
			expectedTris:  `MULTIPOLYGON (((10 30,10 10,20 15,10 30)),((10 30,20 15,20 25,10 30)),((10 30,20 25,15 35,10 30)),((10 30,15 35,20 45,10 30)),((20 45,15 35,23.226 30.887,20 45)),((20 45,23.226 30.887,40 40,20 45)),((40 40,23.226 30.887,34.167 25.417,40 40)),((40 40,34.167 25.417,45 20,40 40)),((30 5,45 20,28 10,30 5)),((30 5,28 10,10 10,30 5)),((10 10,28 10,20 15,10 10)),((20 15,28 10,26.154 18.077,20 15)),((20 15,26.154 18.077,25.161 22.419,20 15)),((20 15,25.161 22.419,20 25,20 15)),((20 25,25.161 22.419,23.226 30.887,20 25)),((20 25,23.226 30.887,15 35,20 25)),((23.226 30.887,25.161 22.419,34.167 25.417,23.226 30.887)),((34.167 25.417,25.161 22.419,30 20,34.167 25.417)),((34.167 25.417,30 20,28 10,34.167 25.417)),((34.167 25.417,28 10,45 20,34.167 25.417)),((28 10,30 20,26.154 18.077,28 10)),((26.154 18.077,30 20,25.161 22.419,26.154 18.077)))`,
			skip:          `this test is giving correct results, but due to map ordering it is giving different results sometimes. We'll need to modify the routine to use something other than map ordering so the results are consistent.`,
		},

		{ // 10
			inputWKT: `MULTILINESTRING ((10 924,2099 220), (96 -46,137 -7), (41 -64,1190.908203125 -64), (4160 -64,4160 4160), (1965 847,2080 546), (364 390,1188 120), (1188 120,1216 12), (2244 -64,4160 -64), (1965 1228,2112 1305), (1930 1052,1965 1228), (-64 -64,-64 729.8095703125), (2026 2918,2244 3041), (1824 2556,2163 1449), (247 303,364 390), (-64 4160,4160 4160), (1178 2076,1408 2188), (41 -48,96 -46), (1184 2054,1431 2153), (1431 2153,1824 2556), (1930 1052,1965 847), (2080 546,2122 319), (2099 220,2122 319), (137 -7,247 303), (-64 -64,41 -64), (1190.908203125 -64,2244 -64), (2244 -64,2244 3041), (1178 2076,1184 2054), (41 -64,41 -48), (-64 729.8095703125,-64 4160), (1408 2188,2026 2918), (2112 1305, 2163 1449), (-64 729.8095703125,10 924), (1190.908203125 -64,1216 12))`,
			inputWKB: `01050000002100000001020000000200000000000000000024400000000000e08c40000000000066a0400000000000806b40010200000002000000000000000000584000000000000047c000000000002061400000000000001cc0010200000002000000000000000080444000000000000050c000000000a29b924000000000000050c0010200000002000000000000000040b04000000000000050c0000000000040b040000000000040b0400102000000020000000000000000b49e400000000000788a40000000000040a04000000000001081400102000000020000000000000000c07640000000000060784000000000009092400000000000005e4001020000000200000000000000009092400000000000005e4000000000000093400000000000002840010200000002000000000000000088a14000000000000050c0000000000040b04000000000000050c00102000000020000000000000000b49e400000000000309340000000000080a04000000000006494400102000000020000000000000000289e4000000000007090400000000000b49e40000000000030934001020000000200000000000000000050c000000000000050c000000000000050c0000000007ace86400102000000020000000000000000a89f400000000000cca640000000000088a1400000000000c2a7400102000000020000000000000000809c400000000000f8a3400000000000e6a0400000000000a496400102000000020000000000000000e06e400000000000f072400000000000c07640000000000060784001020000000200000000000000000050c0000000000040b040000000000040b040000000000040b0400102000000020000000000000000689240000000000038a0400000000000009640000000000018a140010200000002000000000000000080444000000000000048c0000000000000584000000000000047c0010200000002000000000000000080924000000000000ca04000000000005c96400000000000d2a04001020000000200000000000000005c96400000000000d2a0400000000000809c400000000000f8a3400102000000020000000000000000289e4000000000007090400000000000b49e400000000000788a40010200000002000000000000000040a0400000000000108140000000000094a0400000000000f07340010200000002000000000000000066a0400000000000806b40000000000094a0400000000000f0734001020000000200000000000000002061400000000000001cc00000000000e06e400000000000f0724001020000000200000000000000000050c000000000000050c0000000000080444000000000000050c001020000000200000000000000a29b924000000000000050c0000000000088a14000000000000050c0010200000002000000000000000088a14000000000000050c0000000000088a1400000000000c2a7400102000000020000000000000000689240000000000038a040000000000080924000000000000ca040010200000002000000000000000080444000000000000050c0000000000080444000000000000048c001020000000200000000000000000050c0000000007ace864000000000000050c0000000000040b0400102000000020000000000000000009640000000000018a1400000000000a89f400000000000cca640010200000002000000000000000080a04000000000006494400000000000e6a0400000000000a4964001020000000200000000000000000050c0000000007ace864000000000000024400000000000e08c4001020000000200000000000000a29b924000000000000050c000000000000093400000000000002840`,
			skip:     ` failing with error inserting segments, expected nil got vertex index is missing a vertex: [1178 2076]`,
		},
	}

	for i, tc := range testcases {
		t.Run(strconv.FormatInt(int64(i), 10), fn(tc))
	}
}
